#!/usr/bin/perl
# rotstev.pl 
#
# Generates rotation matrices to rotate Stevens' Operator equivalents by
# phi about y-axis and theta about z-axis. Based on the method of Buckmaster
# (Physica Status Solidi A vol 13, pp 9, 1972) and Rudowicz (J. Phys: C: 
# Solid State Physics, vol 18, pp 1415, 1985).
#
# NB: phi is denoted by f and theta by t in this program
#
# by Duc Le 2006 - duc.le@ucl.ac.uk

use Math::Algebra::Symbols trig=>1;     # exports trig function to my namespace

# The following subroutines were shamelessly stolen from the Perl Cookbook
# by O'Reily, and used for the symbolic matrix multiplications.

sub mmult {
  my ($m1,$m2) = @_;
  my ($m1rows,$m1cols) = matdim($m1);
  my ($m2rows,$m2cols) = matdim($m2);

  unless ($m1cols == $m2rows) {       # raise exception
    die "IndexError: matrices don't match: $m1cols != $m2rows";
  }

  my $result = [];
  my ($i, $j, $k, $m1el, $m2el, $prod_el);

  for $i (range($m1rows)) {
    for $j (range($m2cols)) {
      for $k (range($m1cols)) {
        $m1el = $m1->[$i][$k];
        $m2el = $m2->[$k][$j];
        $prod_el += $m1el * $m2el;
      }
      $result->[$i][$j] = $prod_el;
      $prod_el = 0;
    }
  }

  return $result;
}

sub range { 0 .. ($_[0] - 1) }

sub veclen {
    my $ary_ref = $_[0];
    my $type = ref $ary_ref;
    if ($type ne "ARRAY") { die "$type is bad array ref for $ary_ref" }
    return scalar(@$ary_ref);
}

sub matdim {
    my $matrix = $_[0];
    my $rows = veclen($matrix);
    my $cols = veclen($matrix->[0]);
    return ($rows, $cols);
}

# End of stolen code!

my ($f, $t, $i, $pi) = symbols(qw(f t i pi));
my ($T, $S, $s, $F) = symbols(qw(two seven seventy five));
my ($l, $m, $n);

my $A4 = [
	[2,   0,        0,      0,        0,      0,         0,     0,	     -2],
	[0, 1/sqrt($T), 0,      0,        0,      0,         0,	 1/sqrt($T),  0],
	[0,   0,    sqrt($S),   0,        0,      0,    -sqrt($S),  0,	      0],
	[0,   0,        0,   sqrt($S/$T), 0,   sqrt($S/$T),  0,     0,	      0],
	[0,   0,        0,      0,    2*sqrt($s), 0,         0,     0,	      0],
	[0,   0,        0,   sqrt($S/$T), 0,  -sqrt($S/$T),  0,     0,	      0],
	[0,   0,    sqrt($S),   0,	  0,      0,     sqrt($S),  0,	      0],
	[0, 1/sqrt($T), 0,      0,	  0,      0,         0,	-1/sqrt($T),  0],
	[2,   0,        0,      0,	  0,      0,         0,     0,	      2]
     ];

my $invA4 = [
	[ 1/4,     0,       0,       0,        0,      0,         0,     0,       1/4],
	[   0, 1/sqrt($T),  0,       0,        0,      0,         0,  1/sqrt($T),  0],
	[   0,     0,  0.5/sqrt($S), 0,        0,      0,  0.5/sqrt($S), 0,        0],
	[   0,     0,       0,  1/sqrt($T*$S), 0,  1/sqrt($T*$S), 0,     0,        0],
	[   0,     0,       0,       0,  0.5/sqrt($s), 0,         0,     0,        0],
	[   0,     0,       0,  1/sqrt($T*$S), 0, -1/sqrt($T*$S), 0,     0,        0],
	[   0,     0, -0.5/sqrt($S), 0,        0,      0,  0.5/sqrt($S), 0,        0],
	[   0, 1/sqrt($T),  0,       0,        0,      0,         0, -1/sqrt($T),  0],
	[-1/4,     0,       0,       0,        0,      0,         0,     0,       1/4]
      ];

# --------------------------------------- O4 ------------------------------------- #

my $D4p0p4 =  sqrt($s)/16   * sin($t)**4;
my $D4p0p3 =  sqrt($S*$T)/4 * sin($t)**3 * cos($t);
my $D4p0p2 =  sqrt($F*$T)/8 * sin($t)**2 * (7*cos($t)**2 - 1);
my $D4p0p1 =  sqrt($F)/4    * sin($t)    * cos($t) * (7*cos($t)**2 - 3);
my $D4p0p0 =  (1/8)         * (35*cos($t)**4 - 30*cos($t)**2 + 3);

my $D4p1p0 =  exp( $i*$f) * sqrt($F)/4    * sin($t)     * cos($t)     * (7*cos($t)**2-3);
my $D4p1p1 =  exp( $i*$f) * (1/8)         * (1+cos($t)) * (28*cos($t)**3 - 21*cos($t)**2 - 6*cos($t) + 3);
my $D4p1m1 =  exp(-$i*$f) * (1/8)         * (1-cos($t)) * (28*cos($t)**3 + 21*cos($t)**2 - 6*cos($t) - 3);
my $D4p1p2 =  exp( $i*$f) * sqrt($T)/8    * sin($t)     * (1+cos($t)) * (14*cos($t)**2 - 7*cos($t) - 1);
my $D4p1m2 = -exp(-$i*$f) * sqrt($T)/8    * sin($t)     * (1-cos($t)) * (14*cos($t)**2 + 7*cos($t) - 1);
my $D4p1p3 =  exp( $i*$f) * sqrt($S)/8    * sin($t)**2  * (1+cos($t)) * ( 4*cos($t) - 1);
my $D4p1m3 =  exp(-$i*$f) * sqrt($S)/8    * sin($t)**2  * (1-cos($t)) * ( 4*cos($t) + 1);
my $D4p1p4 =  exp( $i*$f) * sqrt($T*$S)/8 * sin($t)**3  * (1+cos($t));
my $D4p1m4 = -exp(-$i*$f) * sqrt($T*$S)/8 * sin($t)**3  * (1-cos($t));

my $D4p2p0 =  exp( 2*$i*$f) * sqrt($T*$F)/8 * sin($t)**2 * (7*cos($t)**2 - 1);
my $D4p2p1 =  exp( 2*$i*$f) * sqrt($T)/8    * sin($t)    * (1+cos($t)) * (14*cos($t)**2 - 7*cos($t) - 1);
my $D4p2m1 =  exp(-2*$i*$f) * sqrt($T)/8    * sin($t)    * (1-cos($t)) * (14*cos($t)**2 + 7*cos($t) - 1);
my $D4p2p2 =  exp( 2*$i*$f) * (1/4)         * (1+cos($t))**2 * (7*cos($t)**2 - 7*cos($t) + 1);
my $D4p2m2 =  exp(-2*$i*$f) * (1/4)         * (1-cos($t))**2 * (7*cos($t)**2 + 7*cos($t) + 1);
my $D4p2p3 =  exp( 2*$i*$f) * sqrt($T*$S)/8 * sin($t)    * (1+cos($t))**2 * (2*cos($t) - 1);
my $D4p2m3 = -exp(-2*$i*$f) * sqrt($T*$S)/8 * sin($t)    * (1-cos($t))**2 * (2*cos($t) + 1);
my $D4p2p4 =  exp( 2*$i*$f) * sqrt($S)/8    * sin($t)**2 * (1+cos($t))**2;
my $D4p2m4 =  exp(-2*$i*$f) * sqrt($S)/8    * sin($t)**2 * (1-cos($t))**2;

my $D4p3p0 =  exp( 3*$i*$f) * sqrt($F*$S)/4 * sin($t)**3 * cos($t);
my $D4p3p1 =  exp( 3*$i*$f) * sqrt($S)/8    * sin($t)**2 * (1+cos($t)) * (4*cos($t) - 1);
my $D4p3m1 =  exp(-3*$i*$f) * sqrt($S)/8    * sin($t)**2 * (1-cos($t)) * (4*cos($t) + 1);
my $D4p3p2 =  exp( 3*$i*$f) * sqrt($T*$S)/8 * sin($t)   * (1+cos($t))**2 * (2*cos($t) - 1);
my $D4p3m2 =  exp(-3*$i*$f) * sqrt($T*$S)/8 * sin($t)   * (1-cos($t))**2 * (2*cos($t) + 1);
my $D4p3p3 =  exp( 3*$i*$f) * (1/8)         * (1+cos($t))**3 * (4*cos($t) - 3);
my $D4p3m3 =  exp(-3*$i*$f) * (1/8)         * (1-cos($t))**3 * (4*cos($t) + 3);
my $D4p3p4 =  exp( 3*$i*$f) * sqrt($T)/8    * sin($t)   * (1+cos($t))**3;
my $D4p3m4 = -exp(-3*$i*$f) * sqrt($T)/8    * sin($t)   * (1-cos($t))**3;

my $D4p4p0 =  exp( 4*$i*$f) * sqrt($s)/16   * sin($t)**4;
my $D4p4p1 =  exp( 4*$i*$f) * sqrt($T*$S)/8 * sin($t)**3 * (1+cos($t));
my $D4p4m1 =  exp(-4*$i*$f) * sqrt($T*$S)/8 * sin($t)**3 * (1-cos($t));
my $D4p4p2 =  exp( 4*$i*$f) * sqrt($S)/8    * sin($t)**2 * (1+cos($t))**2;
my $D4p4m2 =  exp(-4*$i*$f) * sqrt($S)/8    * sin($t)**2 * (1-cos($t))**2;
my $D4p4p3 =  exp( 4*$i*$f) * sqrt($T)/8    * sin($t)   * (1+cos($t))**3;
my $D4p4m3 =  exp(-4*$i*$f) * sqrt($T)/8    * sin($t)   * (1-cos($t))**3;
my $D4p4p4 =  exp( 4*$i*$f) * (1/16)        * (1+cos($t))**4;
my $D4p4m4 =  exp(-4*$i*$f) * (1/16)        * (1-cos($t))**4;

my $D4 = [
             [ $D4p4p4,  $D4p4p3,  $D4p4p2,  $D4p4p1,  $D4p4p0,  $D4p4m1,  $D4p4m2,  $D4p4m3,  $D4p4m4], 
             [-$D4p3p4,  $D4p3p3,  $D4p3p2,  $D4p3p1,  $D4p3p0,  $D4p3m1,  $D4p3m2,  $D4p3m3, -$D4p3m4], 
             [ $D4p2p4, -$D4p2p3,  $D4p2p2,  $D4p2p1,  $D4p2p0,  $D4p2m1,  $D4p2m2, -$D4p2m3,  $D4p2m4], 
             [-$D4p1p4,  $D4p1p3, -$D4p1p2,  $D4p1p1,  $D4p1p0,  $D4p1m1, -$D4p1m2,  $D4p1m3, -$D4p1m4], 
             [ $D4p0p4, -$D4p0p3,  $D4p0p2, -$D4p0p1,  $D4p0p0,  $D4p0p1,  $D4p0p2,  $D4p0p3,  $D4p0p4], 
             [ $D4p1m4,  $D4p1m3,  $D4p1m2,  $D4p1m1, -$D4p1p0,  $D4p1p1,  $D4p1p2,  $D4p1p3,  $D4p1p4], 
             [ $D4p2m4,  $D4p2m3,  $D4p2m2, -$D4p2m1,  $D4p2p0, -$D4p2p1,  $D4p2p2,  $D4p2p3,  $D4p2p4], 
             [ $D4p3m4,  $D4p3m3, -$D4p3m2,  $D4p3m1, -$D4p3p0,  $D4p3p1, -$D4p3p2,  $D4p3p3,  $D4p3p4], 
             [ $D4p4m4, -$D4p4m3,  $D4p4m2, -$D4p4m1,  $D4p4p0, -$D4p4p1,  $D4p4p2, -$D4p4p3,  $D4p4p4]
         ];

my ($O4m4, $O4m3, $O4m2, $O4m1, $O4p0) = symbols(qw(Ofmf OfmT Ofmt Ofmo Ofpz));
my ($O4p4, $O4p3, $O4p2, $O4p1) = symbols(qw(Ofpf OfpT Ofpt Ofpo));

# ------------------------------------ Finished !! ------------------------------- #

# The operator in the rotated frame. Rx(y) is equivalent to {Oxy} in Rudowicz notation
# and Ox_y, Oxmy is equivalent to [Oxy], [OxyM] in Rudowicz

my $B4 = [ [$O4m4],[$O4m3],[$O4m2],[$O4m1],[$O4p0],[$O4p1],[$O4p2],[$O4p3],[$O4p4] ];

my $tmp1 = mmult($invA4,$B4);
my $tmp2 = mmult($D4, $tmp1);
my $R4 = mmult($A4, $tmp2);

my $S4 = [];
my $M4 = [];
print "Transformation relations for O4q:\n"; 
for $l (0 .. 8) { 
  $S4->[$l] = $R4->[$l][0]->sub(f=>0, t=>$pi/2);
  print $S4->[$l]; print "\n";
  $S4->[$l] = $S4->[$l]->sub(seven=>7,two=>2,seventy=>70,five=>5); 
  $M4->[0][$l] = $S4->[$l]->sub(Ofmf=>1,OfmT=>0,Ofmt=>0,Ofmo=>0,Ofpz=>0,Ofpo=>0,Ofpt=>0,OfpT=>0,Ofpf=>0);
  $M4->[1][$l] = $S4->[$l]->sub(Ofmf=>0,OfmT=>1,Ofmt=>0,Ofmo=>0,Ofpz=>0,Ofpo=>0,Ofpt=>0,OfpT=>0,Ofpf=>0);
  $M4->[2][$l] = $S4->[$l]->sub(Ofmf=>0,OfmT=>0,Ofmt=>1,Ofmo=>0,Ofpz=>0,Ofpo=>0,Ofpt=>0,OfpT=>0,Ofpf=>0);
  $M4->[3][$l] = $S4->[$l]->sub(Ofmf=>0,OfmT=>0,Ofmt=>0,Ofmo=>1,Ofpz=>0,Ofpo=>0,Ofpt=>0,OfpT=>0,Ofpf=>0);
  $M4->[4][$l] = $S4->[$l]->sub(Ofmf=>0,OfmT=>0,Ofmt=>0,Ofmo=>0,Ofpz=>1,Ofpo=>0,Ofpt=>0,OfpT=>0,Ofpf=>0);
  $M4->[5][$l] = $S4->[$l]->sub(Ofmf=>0,OfmT=>0,Ofmt=>0,Ofmo=>0,Ofpz=>0,Ofpo=>1,Ofpt=>0,OfpT=>0,Ofpf=>0);
  $M4->[6][$l] = $S4->[$l]->sub(Ofmf=>0,OfmT=>0,Ofmt=>0,Ofmo=>0,Ofpz=>0,Ofpo=>0,Ofpt=>1,OfpT=>0,Ofpf=>0);
  $M4->[7][$l] = $S4->[$l]->sub(Ofmf=>0,OfmT=>0,Ofmt=>0,Ofmo=>0,Ofpz=>0,Ofpo=>0,Ofpt=>0,OfpT=>1,Ofpf=>0);
  $M4->[8][$l] = $S4->[$l]->sub(Ofmf=>0,OfmT=>0,Ofmt=>0,Ofmo=>0,Ofpz=>0,Ofpo=>0,Ofpt=>0,OfpT=>0,Ofpf=>1);
}

print "\nRotation Matrix for O4q:\n";
for $l (0 .. 8) { for $m (0 .. 8) {
  print $M4->[$l][$m]; print "\t"; } print "\n"; }
    
