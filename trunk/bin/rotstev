#!/usr/bin/perl
# rotstev.pl 
#
# Generates rotation matrices to rotate Stevens' Operator equivalents by
# phi about y-axis and theta about z-axis. Based on the method of Buckmaster
# (Physica Status Solidi A vol 13, pp 9, 1972) and Rudowicz (J. Phys: C: 
# Solid State Physics, vol 18, pp 1415, 1985).
#
# NB: phi is denoted by f and theta by t in this program
#
# by Duc Le 2006 - duc.le@ucl.ac.uk

use Math::Algebra::Symbols trig=>1;     # exports trig function to my namespace

# The following subroutines were shamelessly stolen from the Perl Cookbook
# by O'Reily, and used for the symbolic matrix multiplications.

sub mmult {
#  my ($m1,$m2) = @_;
#  my ($m1rows,$m1cols) = matdim($m1);
#  my ($m2rows,$m2cols) = matdim($m2);
#  my (@m1,@m2) = @_;
  my ($m1_pt,$m2_pt) = @_;
#  my @m1 = $$m1_pt;
#  my @m2 = $$m2_pt;
  print "$m1_pt\t$m2_pt\n";
  my ($m1rows,$m1cols) = matdim(@m1);
  my ($m2rows,$m2cols) = matdim(@m2);

  unless ($m1cols == $m2rows) {       # raise exception
    die "IndexError: matrices don't match: $m1cols != $m2rows";
  }

#  my $result = [];
  my @result = ();
  my ($i, $j, $k);

#  for $i (range($m1rows)) {
#    for $j (range($m2cols)) {
#      for $k (range($m1cols)) {
#        $result->[$i][$j] += $m1->[$i][$k] * $m2->[$k][$j];
#      }
#    }
#  }
  for $i (0 .. $m1rows) {
    for $j (0 .. $m2cols) {
      for $k (0 .. $m1cols) {
        $result[$i][$j] += $m1[$i][$k] * $m2[$k][$j];
      }
    }
  }

  return $result;
}

#sub range { 0 .. ($_[0] - 1) }

#sub veclen {
#    my $ary_ref = $_[0];
#    my $type = ref $ary_ref;
#    if ($type ne "ARRAY") { die "$type is bad array ref for $ary_ref" }
#    return scalar(@$ary_ref);
#}

sub matdim {
#    my $matrix = $_[0];
#    my $rows = veclen($matrix);
#    my $cols = veclen($matrix->[0]);
    my @matrix = @_;
    $rows = $#matrix;
    $cols = @{@matrix->[0]} - 1;   
    print "r:$rows  c:$cols\n";
    return ($rows, $cols);
}

# End of stolen code!

my ($f, $t, $i, $o, $pi) = symbols(qw(f t i 1 pi));

# Transformation matrix between Stevens and Buckmaster operator equivalents
my $A1 = [
	[1/sqrt(2),	0,	1/sqrt(2)  ],
	[0,		1,	0	   ],
	[1/sqrt(2),	0,	-1/sqrt(2) ]
     ];

my $A2 = [
	[1,	0,	0,	 0,	-1],
	[0,	1/2,	0,	 1/2,	0 ],
	[0,	0,	sqrt(6), 0,	0 ],
	[0,	1/2,	0,	 -1/2,	0 ],
	[1,	0,	0,	 0,	1 ]
     ];

my $A4 = [
	[2, 	0,	0,	 0,	  0,	0,	0,	 0,	-2  ],
	[0,	1/sqrt(2), 0,	 0,	  0,	0,	0,	1/sqrt(2), 0],
	[0,	0,	sqrt(7), 0,	  0,	0,	-sqrt(7),0,	0   ],
	[0,	0,	0,	sqrt(7/2),0,	sqrt(7/2),  0,	 0,	0   ],
	[0,	0,	0,	 0,	2*sqrt(70), 0,	0,	 0,	0   ],
	[0,	0,	0,	sqrt(7/2),0,	-sqrt(7/2), 0,	 0,	0   ],
	[0,	0,	sqrt(7), 0,	  0,	0,	sqrt(7), 0,	0   ],
	[0,	1/sqrt(2), 0,	 0,	  0,	0,	0,	-1/sqrt(2),0],
	[2,	0,	0,	 0,	  0,	0,	0,	 0,	2   ]
     ];

my $A6 = [
	[4,   0,   0,   0,   0,   0,   0,    0,   0,  0,    0,   0,      -4],
	[0, 2/sqrt(3),0,0,   0,   0,   0,    0,   0,  0,    0, 2/sqrt(3), 0],
	[0,   0,4*sqrt(11/6),0, 0,0,   0,    0,   0,  0,-4*sqrt(11/6),0,  0],
	[0,   0,   0,2*sqrt(11/5),0,0, 0,    0,   0,2*sqrt(11/5),0,   0,  0],
	[0,   0,   0,   0,4*sqrt(11/5),0, 0, 0,-4*sqrt(11/5), 0, 0,   0,  0],
	[0,   0,   0,   0,   0, sqrt(22), 0,  sqrt(22), 0,    0, 0,   0,  0],
        [0,   0,   0,   0,   0,   0,4*sqrt(231), 0,     0,    0, 0,   0,  0],
	[0,   0,   0,   0,   0,sqrt(22),  0, -sqrt(22), 0,    0, 0,   0,  0],
	[0,   0,   0,   0,4*sqrt(11/5),0, 0,0,  4*sqrt(11/5), 0, 0,   0,  0],
	[0,   0,   0,2*sqrt(11/5),0, 0,0,   0,   0,-2*sqrt(11/5),0,   0,  0],
	[0,   0,4*sqrt(11/6),0, 0,0,   0,   0,   0,   0, 4*sqrt(11/6),0,  0],
	[0, 2/sqrt(3),0,0,   0,   0,   0,   0,   0,   0,   0, -2/sqrt(3), 0],
	[4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,    0,       4]
      ];

#my $invA2 = [
my @invA2 = (
	[       1/2,         0,         0,         0,       1/2],
	[         0,         1,         0,         1,         0],
	[         0,         0, sqrt(1/6),         0,         0],
	[         0,         1,         0,        -1,         0],
	[      -1/2,         0,         0,         0,       1/2]
#      ];
      );

my $invA4 = [
	[ 1/4,     0,      0,      0,      0,      0,      0,     0,      1/4],
	[   0, sqrt(1/2),  0,      0,      0,      0,      0,  sqrt(1/2), 0],
	[   0,     0,  sqrt(1/28), 0,      0,      0, sqrt(1/28), 0,      0],
	[   0,     0,      0,  sqrt(1/14), 0,  sqrt(1/14), 0,     0,      0],
	[   0,     0,      0,      0, sqrt(1/280), 0,      0,     0,      0],
	[   0,     0,      0,  sqrt(1/14), 0, -sqrt(1/14), 0,     0,      0],
	[   0,     0, -sqrt(1/28), 0,      0,      0, sqrt(1/28), 0,      0],
	[   0, sqrt(1/2),  0,      0,      0,      0,      0, -sqrt(1/2), 0],
	[-1/4,     0,      0,      0,      0,      0,      0,     0,      1/4]
      ];

my $invA6 = [
	[    1/8,0,0,0,0,0,0,0,0,0,0,0,                1/8],
	[0,   sqrt(3/16),0,0,0,0,0,0,0,0,0,   sqrt(3/16),0],
	[0,0,  sqrt(3/352),0,0,0,0,0,0,0,  sqrt(3/352),0,0],
	[0,0,0,  sqrt(5/176),0,0,0,0,0,  sqrt(5/176),0,0,0],
	[0,0,0,0,  sqrt(5/704),0,0,0,  sqrt(5/704),0,0,0,0],
	[0,0,0,0,0,   sqrt(1/88),0,   sqrt(1/88),0,0,0,0,0],
	[0,0,0,0,0,0, sqrt(1/3696),0,0,0,0,0,0],
	[0,0,0,0,0,   sqrt(1/88),0,  -sqrt(1/88),0,0,0,0,0],
	[0,0,0,0, -sqrt(5/704),0,0,0,  sqrt(5/704),0,0,0,0],
	[0,0,0,  sqrt(5/176),0,0,0,0,0, -sqrt(5/176),0,0,0],
	[0,0, -sqrt(3/352),0,0,0,0,0,0,0,  sqrt(3/352),0,0],
	[0,   sqrt(3/16),0,0,0,0,0,0,0,0,0,  -sqrt(3/16),0],
	[   -1/8,0,0,0,0,0,0,0,0,0,0,0,                1/8]
      ];

# --------------------------------------- O1 ------------------------------------- #

my $D10p0 = cos($t);
my $D10p1 = (sqrt(2)/2)*sin($t);

my $D1p1m1 = exp( $i*$f) * (1/2)*(1-cos($t));
my $D1p1p1 = exp( $i*$f) * (1/2)*(1+cos($t));
my $D1p1p0 = exp( $i*$f) * (sqrt(2)/2)*sin($t);

my $D1m1m1 = exp(-$i*$f) * (1/2)*(1+cos($t));
my $D1m1p1 = exp(-$i*$f) * (1/2)*(1-cos($t));
my $D1m1p0 = exp(-$i*$f) * (sqrt(2)/2)*sin($t);

my @D1 =  (
	    [ $D1m1m1,  $D1m1p0, $D1m1p1],
	    [-$D10p1,   $D10p0,  $D10p1 ],
	    [ $D1p1m1, -$D1p1p0, $D1p1p1]
          );

my ($O1m1, $O1p0, $O1p1) = symbols(qw(O1m1 O1p0 O1p1));

#print "$D10p0\t$D10p1\n";
#
#for $i (0 .. 2) { 
#  for $j (0 .. 2) { 
#    print "$D1[$i][$j]\t"; } 
#  print "\n";
#}

#$_ = $D1[1][1] * exp(-2*$i*$f); print "$_\n";
#
#print "$#D1\n";


# --------------------------------------- O2 ------------------------------------- #

my $D20p2 = (sqrt(6)/4)*sin($t)^2;
my $D20p1 = (sqrt(6)/2)*sin($t)*cos($t);
my $D20p0 = (1/2)*(3*cos($t)^2 - 1);

my $D2m1m2 = exp(-$i*$f) * -(1/2)*sin($t)*(1+cos($t));
my $D2m1p2 = exp(-$i*$f) *  (1/2)*sin($t)*(1-cos($t));
my $D2m1m1 = exp(-$i*$f) *  (1/2)*(1+cos($t))*(2*cos($t)-1);
my $D2m1p1 = exp(-$i*$f) *  (1/2)*(1-cos($t))*(2*cos($t)+1);
my $D2m1p0 = exp(-$i*$f) *  (sqrt(6)/2)*sin($t)*cos($t);

my $D2p1m2 = exp( $i*$f) * -(1/2)*sin($t)*(1-cos($t));
my $D2p1p2 = exp( $i*$f) *  (1/2)*sin($t)*(1+cos($t));
my $D2p1m1 = exp( $i*$f) *  (1/2)*(1-cos($t))*(2*cos($t)+1);
my $D2p1p1 = exp( $i*$f) *  (1/2)*(1+cos($t))*(2*cos($t)-1);
my $D2p1p0 = exp( $i*$f) * -(sqrt(6)/2)*sin($t)*cos($t);

my $D2m2m2 = exp(-2*$i*$f) *  (1/4)*(1+cos($t))^2;
my $D2m2p2 = exp(-2*$i*$f) *  (1/4)*(1-cos($t))^2;
my $D2m2m1 = exp(-2*$i*$f) *  (1/2)*sin($t)*(1+cos($t));
my $D2m2p1 = exp(-2*$i*$f) *  (1/2)*sin($t)*(1-cos($t));
my $D2m2p0 = exp(-2*$i*$f) *  (sqrt(6)/4)*sin($t)^2;

my $D2p2m2 = exp( 2*$i*$f) *  (1/4)*(1-cos($t))^2;
my $D2p2p2 = exp( 2*$i*$f) *  (1/4)*(1+cos($t))^2;
my $D2p2m1 = exp( 2*$i*$f) * -(1/2)*sin($t)*(1-cos($t));
my $D2p2p1 = exp( 2*$i*$f) * -(1/2)*sin($t)*(1+cos($t));
my $D2p2p0 = exp( 2*$i*$f) *  (sqrt(6)/4)*sin($t)^2;

#my $D2 = [
my @D2 = (
	   [$D2m2m2, $D2m2m1, $D2m2p0, $D2m2p1, $D2m2p2],
           [$D2m1m2, $D2m1m1, $D2m1p0, $D2m1p1, $D2m1p2],
           [$D20p2, -$D20p1,  $D20p0,  $D20p1,  $D20p2 ],
           [$D2p1m2, $D2p1m1, $D2p1p0, $D2p1p1, $D2p1p2],
           [$D2p2m2, $D2p2m1, $D2p2p0, $D2p2p1, $D2p2p2]
#         ];
         );

my ($O2m2, $O2m1, $O2p0, $O1p1, $O2p2) = symbols(qw(O2m2 O2m1 O2p0 O2p1 O2p2));


#my $B2 = [ [O2m2],[O2m1],[O2p0],[O2p1],[O2p2] ];
my @B2 = ( [O2m2],[O2m1],[O2p0],[O2p1],[O2p2] );

#my $R2 = mmult($invA2,$B2);
my @R2 = mmult(\@invA2,\@B2);
#my $tmp = mmult($D2, $R2);
#my $R2 = mmult($A2, $tmp);

#for $i (0 .. 5) { if ($_ = $R2->[$i][0]) { print "$Bo2{$i} = $_\n"; } }
#for $i (0 .. 5) { $_ = $R2->[$i][0]; print "$_\n"; } 

#print $B2;
for $i (0 .. 4) { 
  for $j (0 .. 4) { 
    $_ = $R2->[$i][$j]; print "$_\t"; } 
  print "\n";
}

matdim(@D2);

#$_ = exp(2*$i*$f); print "$_\n";
