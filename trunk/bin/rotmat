#!/usr/bin/perl

use PDL;
use Getopt::Long;

# The following subroutines were shamelessly stolen from the Perl Cookbook
# by O'Reily (Recipe 2.14), and used for the matrix multiplications.

sub mmult {
    my ($m1,$m2) = @_;
    my ($m1rows,$m1cols) = matdim($m1);
    my ($m2rows,$m2cols) = matdim($m2);

    unless ($m1cols == $m2rows) {       # raise exception
        die "IndexError: matrices don't match: $m1cols != $m2rows";
    }

    my $result = [];
    my ($i, $j, $k);

    for $i (range($m1rows)) {
        for $j (range($m2cols)) {
            for $k (range($m1cols)) {
                $result->[$i][$j] += $m1->[$i][$k] * $m2->[$k][$j];
            }
        }
    }
    return $result;
}

sub range { 0 .. ($_[0] - 1) }

sub veclen {
    my $ary_ref = $_[0];
    my $type = ref $ary_ref;
    if ($type ne "ARRAY") { die "$type is bad array ref for $ary_ref" }
    return scalar(@$ary_ref);
}

sub matdim {
    my $matrix = $_[0];
    my $rows = veclen($matrix);
    my $cols = veclen($matrix->[0]);
    return ($rows, $cols);
}

# End of stolen code!
sub usage() {
  print STDERR << "EOF";

    $0:
    Calculates a set of  crystal field  parameters for  Stevens equivalent
    operators in which Jx || c, Jy || b and Jz || a, from a set of crystal
    field parameters with Jx || a, Jy || b, and Jz || c. It is for use  by
    the program mcphase which requires this axis convention.

    The calculations are  done by means of matrix  multiplication based on
    the method of Buckmaster (phys. stat. sol. a, vol 13,  pp 9, 1972) and
    Rudowicz (J. Phys: Solid State Phys., vol 18, pp 1415, 1985).   

    This program uses the  Perl Data Language (PDL) modules  which must be
    installed.

    usage: $0 [-h] [--help] 
              [-i input_file] [--input input_file]
	      [-o output_file] [--output output_file]

     -h          : this (help) message
     -i in_file  : input CF parameters file in cfield or mcphase formats
     -B params   : input parameters from  standards input.  
     -o out_file : output CF parameters file in mcphase format

    if -i is omitted, the program will  assume the input CF parameters are
          given on the command line in the format: Bkq=x.xx,Bkq=x.xx, etc.
          e.g. B20=0.21,B40=0.0005,B60=0.051,B66=0.626

    if -o is omitted, the program prints the parameters to standard output. 

EOF
  exit;
}

# see http://aplawrence.com/Unix/perlgetops.html for details of GetOptions

GetOptions("help"=>\$helpflag,
	   "input=s"=>\$input,
	   "output=s"=>\$output);
	   
usage() if $helpflag;

if (!$input && !$ARGV[0]) { 
  print STDERR "$0: requires at least input file or CF parameters on command line.\n";
  exit;
}

my $MR2 = pdl [
            [    0, -1/2,    0,    0,    0],
            [    2,    0,    0,    0,    0],
            [    0,    0, -1/2,    0,  1/2],
            [    0,    0,    0,   -1,    0],
            [    0,    0,  3/2,    0,  1/2]
          ];

my $MR4 = pdl [
            [    0, -1/8,    0, -7/8,    0,    0,    0,    0,    0],
            [    1,    0,  7/2,    0,    0,    0,    0,    0,    0],
            [    0, -1/4,    0,  1/4,    0,    0,    0,    0,    0],
            [    1,    0, -1/2,    0,    0,    0,    0,    0,    0],
            [    0,    0,    0,    0,  3/8,    0, -1/8,    0,  1/8],
            [    0,    0,    0,    0,    0,  3/4,    0, -1/4,    0],
            [    0,    0,    0,    0, -5/2,    0,  1/2,    0,  1/2],
            [    0,    0,    0,    0,    0, -7/4,    0, -3/4,    0],
            [    0,    0,    0,    0, 35/8,    0,  7/8,    0,  1/8]
          ];

my $MR6 = pdl [
  [      0,  -1/32,      0, -11/32,      0, -33/32,      0,      0,      0,      0,      0,      0,      0],
  [    3/8,      0,   11/4,      0,   33/8,      0,      0,      0,      0,      0,      0,      0,      0],
  [      0,   -1/8,      0,   -3/8,      0,    3/8,      0,      0,      0,      0,      0,      0,      0],
  [    5/8,      0,    5/4,      0,   -9/8,      0,      0,      0,      0,      0,      0,      0,      0],
  [      0,  -5/32,      0,   9/32,      0,  -5/32,      0,      0,      0,      0,      0,      0,      0],
  [    3/4,      0,   -1/2,      0,    1/4,      0,      0,      0,      0,      0,      0,      0,      0],
  [      0,      0,      0,      0,      0,      0,  -5/16,      0,   1/16,      0,  -1/16,      0,   1/16],
  [      0,      0,      0,      0,      0,      0,      0,   -5/8,      0,    3/8,      0,   -1/8,      0],
  [      0,      0,      0,      0,      0,      0, 105/32,      0, -17/32,      0,   5/32,      0,  15/32],
  [      0,      0,      0,      0,      0,      0,      0,  15/16,      0,  -1/16,      0,  -5/16,      0],
  [      0,      0,      0,      0,      0,      0, -63/16,      0,   3/16,      0,  13/16,      0,   3/16],
  [      0,      0,      0,      0,      0,      0,      0, -33/16,      0, -33/16,      0,  -5/16,      0],
  [      0,      0,      0,      0,      0,      0, 231/32,      0,  33/32,      0,  11/32,      0,   1/32]
];

my $MS2 = [
            [    0, -1/2,    0,    0,    0],
            [    2,    0,    0,    0,    0],
            [    0,    0, -1/2,    0,  1/2],
            [    0,    0,    0,   -1,    0],
            [    0,    0,  3/2,    0,  1/2]
          ];

my $MS4 = [
            [    0, -1/8,    0, -7/8,    0,    0,    0,    0,    0],
            [    1,    0,  7/2,    0,    0,    0,    0,    0,    0],
            [    0, -1/4,    0,  1/4,    0,    0,    0,    0,    0],
            [    1,    0, -1/2,    0,    0,    0,    0,    0,    0],
            [    0,    0,    0,    0,  3/8,    0, -1/8,    0,  1/8],
            [    0,    0,    0,    0,    0,  3/4,    0, -1/4,    0],
            [    0,    0,    0,    0, -5/2,    0,  1/2,    0,  1/2],
            [    0,    0,    0,    0,    0, -7/4,    0, -3/4,    0],
            [    0,    0,    0,    0, 35/8,    0,  7/8,    0,  1/8]
          ];

my $MS6 = [
  [      0,  -1/32,      0, -11/32,      0, -33/32,      0,      0,      0,      0,      0,      0,      0],
  [    3/8,      0,   11/4,      0,   33/8,      0,      0,      0,      0,      0,      0,      0,      0],
  [      0,   -1/8,      0,   -3/8,      0,    3/8,      0,      0,      0,      0,      0,      0,      0],
  [    5/8,      0,    5/4,      0,   -9/8,      0,      0,      0,      0,      0,      0,      0,      0],
  [      0,  -5/32,      0,   9/32,      0,  -5/32,      0,      0,      0,      0,      0,      0,      0],
  [    3/4,      0,   -1/2,      0,    1/4,      0,      0,      0,      0,      0,      0,      0,      0],
  [      0,      0,      0,      0,      0,      0,  -5/16,      0,   1/16,      0,  -1/16,      0,   1/16],
  [      0,      0,      0,      0,      0,      0,      0,   -5/8,      0,    3/8,      0,   -1/8,      0],
  [      0,      0,      0,      0,      0,      0, 105/32,      0, -17/32,      0,   5/32,      0,  15/32],
  [      0,      0,      0,      0,      0,      0,      0,  15/16,      0,  -1/16,      0,  -5/16,      0],
  [      0,      0,      0,      0,      0,      0, -63/16,      0,   3/16,      0,  13/16,      0,   3/16],
  [      0,      0,      0,      0,      0,      0,      0, -33/16,      0, -33/16,      0,  -5/16,      0],
  [      0,      0,      0,      0,      0,      0, 231/32,      0,  33/32,      0,  11/32,      0,   1/32]
];

my %B=();

open (input_file, $input) or die "$0: cannot open $input for input CF parameters";

while(<input_file>) {                              # Selects out lines with crystal field parameters
  if ($_ =~ /(B[0-9][\-0-9][ 0-9]).*[=:]\s*([- ]\d\.\d*)/ ) { 
                                                   # () are groups which may be access with $1, $2 etc.
                                                   # * means match previous char any number of times.
                                                   # Parameters are of form Bkq = x.xx or Bkq : x.xx
                                                   # \s matches whitespace characters.
						   
    $B{$1}=$2;                                     # Assigns values of CF parameters to a hash.
  }
}

my $B2 = pdl [ [$B{"B2-2"}],[$B{"B2-1"}],[$B{"B20 "}],[$B{"B21 "}],[$B{"B22 "}] ];
my $R2 = $MR2 x $B2;
my $B4 = pdl [ [$B{"B4-4"}],[$B{"B4-3"}],[$B{"B4-2"}],[$B{"B4-1"}],[$B{"B40 "}],[$B{"B41 "}],[$B{"B42 "}],[$B{"B43 "}],[$B{"B44 "}] ];
my $R4 = $MR4 x $B4;
my $B6 = pdl [ [$B{"B6-6"}],[$B{"B6-5"}],[$B{"B6-4"}],[$B{"B6-3"}],[$B{"B6-2"}],[$B{"B6-1"}],[$B{"B60 "}],[$B{"B61 "}],[$B{"B62 "}],[$B{"B63 "}],[$B{"B64 "}],[$B{"B65 "}],[$B{"B66 "}] ];
my $R6 = $MR6 x $B6;

my $C2 = [ [$B{"B2-2"}],[$B{"B2-1"}],[$B{"B20 "}],[$B{"B21 "}],[$B{"B22 "}] ];
my $S2 = mmult($MS2, $C2);
my $C4 = [ [$B{"B4-4"}],[$B{"B4-3"}],[$B{"B4-2"}],[$B{"B4-1"}],[$B{"B40 "}],[$B{"B41 "}],[$B{"B42 "}],[$B{"B43 "}],[$B{"B44 "}] ];
my $S4 = mmult($MS4, $C4);
my $C6 = [ [$B{"B6-6"}],[$B{"B6-5"}],[$B{"B6-4"}],[$B{"B6-3"}],[$B{"B6-2"}],[$B{"B6-1"}],[$B{"B60 "}],[$B{"B61 "}],[$B{"B62 "}],[$B{"B63 "}],[$B{"B64 "}],[$B{"B65 "}],[$B{"B66 "}] ];
my $S6 = mmult($MS6, $C6);

my %Bo2 = (0, "B2-2", 1, "B2-1", 2, "B20 ", 3, "B21 ", 4, "B22 ");
my %Bo4 = (0, "B4-4", 1, "B4-3", 2, "B4-2", 3, "B4-1", 4, "B40 ", 5, "B41 ", 6, "B42 ", 7, "B43 ", 8, "B44 ");
my %Bo6 = (0, "B6-6", 1, "B6-5", 2, "B6-4", 3, "B6-3", 4, "B6-2", 5, "B6-1", 6, "B60 ", 7, "B61 ", 8, "B62 ", 9, "B63 ", 10, "B64 ", 11, "B65 ", 12, "B66 ");

if (!$output) {
#  foreach ($B2) { print $_;}

#  print $R2;
#  print $R4;
#  print $R6;

#  my ($S2r,$S2c) = matdim($S2);
#  print "$S2r\t$S2c\n";
#  for $i (0 .. 5) { $_ = $S2->[$i][0]; print "$_\t"; } print "\n";
#  for $i (0 .. 9) { $_ = $S4->[$i][0]; print "$_\t"; } print "\n";
#  for $i (0 .. 13) { $_ = $S6->[$i][0]; print "$_\t"; } print "\n";
#  
#  print "MS2:$MS2->[0][1]\n";
#  foreach $elem (@S2) { print "$elem\n"; }
#  print "$S2[0]\t$S2[1]\n";

  for $i (0 .. 5) { if ($_ = $S2->[$i][0]) { print "$Bo2{$i} = $_\n"; } }
  for $i (0 .. 9) { if ($_ = $S4->[$i][0]) { print "$Bo4{$i} = $_\n"; } }
  for $i (0 .. 13) { if ($_ = $S6->[$i][0]) { print "$Bo6{$i} = $_\n"; } }
  
}
